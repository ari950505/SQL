----21/05/12/수-----------------------------------------------------------------

---------GROUP함수----------------------------------------------------------------
--group by = grouping
SELECT AVG(SALARY), MAX(SALARY), MIN(SALARY), SUM(SALARY)
FROM EMPLOYEES
WHERE JOB_ID LIKE 'SA%';

SELECT DEPARTMENT_ID, AVG(SALARY)--GROUPING된 GROUP별로 AVG가 구해짐. SUM, MAX, MIN등도 마찬가지
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID;

SELECT DEPARTMENT_ID, AVG(SALARY)
FROM EMPLOYEES
WHERE AVG(SALARY) > 2000 --WHERE 절에는 그룹함수(AVG,SUM,MIN,MAX등등) 사용 불가능
GROUP BY DEPARTMENT_ID;

SELECT DEPARTMENT_ID, AVG(SALARY)
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID
HAVING AVG(SALARY) > 2000;--GROUP BY 쓸때 조건을 두려면 WHERE 대신 HAVING절을 쓰면 됨.
ORDR BY AVG(SALARY);

---Q.일반조건이 필요할때...?
SELECT JOB_ID, AVG(SALARY) AS PAYROLL
FROM EMPLOYEES
WHERE JOB_ID NOT LIKE 'SA%'
GROUP BY JOB_ID
HAVING AVG(SALARY) > 8000
ORDER BY AVG(SALARY) DESC;--SORTING하고 싶으면 ORDER BY 사용

---------JOIN함수---------------------------------------------------------------

------ORACLE JOIN-------
SELECT E.first_name, E.department_id, D.department_name
FROM employees E, departments D --employees는 E로 department는 D로 간단하게 별명을 짓겠다!!
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID;
--EQ JOIN은 WHERE절에 함. 

-----CARTESIAN PRODUCT-----
SELECT E.FIRST_NAME AS EMPLOYEE_NAME, M.FIRST_NAME AS MANAGER_NAME
FROM EMPLOYEES E, EMPLOYEES M --왜 똑같은걸 이렇게 해...?
WHERE E.MANAGER_ID = M.EMPLOYEE_ID AND E.EMPLOYEE_ID = 103; 

SELECT E.EMPLOYEE_ID, E.FIRST_NAME, E.HIRE_DATE, J.START_DATE, J.END_DATE, J.JOB_ID, J.DEPARTMENT_ID
FROM EMPLOYEES E, JOB_HISTORY J
WHERE E.EMPLOYEE_ID = J.EMPLOYEE_ID(+)
ORDER BY J.EMPLOYEE_ID;
--총 107번이어야 하는데 왜 110번?? --> 직무 바뀐사람들이 있기 때문에

SELECT E.EMPLOYEE_ID, E.FIRST_NAME, E.HIRE_DATE, J.START_DATE, J.END_DATE, J.JOB_ID, J.DEPARTMENT_ID
FROM EMPLOYEES E, JOB_HISTORY J
WHERE E.EMPLOYEE_ID = J.EMPLOYEE_ID(+)--+가 붙어있는쪽 기준으로 보여주는 RIGHT OUTER JOIN임. Q.NULL로 보여주고 싶은 쪽에 플러스를 넣어줌...?
ORDER BY J.EMPLOYEE_ID;

--------ANSI JOIN--------
--부서의 주소를 가져오기
SELECT E.FIRST_NAME AS NAME, D.DEPARTMENT_NAME AS DEPARTMENT,
    L.STREET_ADDRESS || ',' || L.CITY || ',' || L.STATE_PROVINCE AS ADDRESS
FROM EMPLOYEES E
JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
JOIN LOCATIONS L
ON D.LOCATION_ID= L.LOCATION_ID;
WHERE E.EMPLOYEE_ID = 103;

--위랑 아래랑 조건 준 장소만 다르고 결과는 같음!!

SELECT E.FIRST_NAME AS NAME, D.DEPARTMENT_NAME AS DEPARTMENT,
    L.STREET_ADDRESS || ',' || L.CITY || ',' || L.STATE_PROVINCE AS ADDRESS
FROM EMPLOYEES E
JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID AND E.EMPLOYEE_ID = 103
JOIN LOCATIONS L
ON D.LOCATION_ID= L.LOCATION_ID;

SELECT FIRST_NAME, DEPARTMENT_NAME --이 COLOUMN들은 오로지 EMPLOYEES테이블에만 있기 때문에 E.FIRST_NAME 이런식으로 표현안함. 근데 그렇더라도 해주는게 좋음.
FROM EMPLOYEES E
LEFT JOIN DEPARTMENTS D --기본이 LEFT JOIN이고, 오라클에선 LEFT,RIGHT 구분을 (+)로 함.
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
WHERE E.DEPARTMENT_ID IS NULL;

SELECT E. EMPLOYEE_ID, E.FIRST_NAME, E.HIRE_DATE,J.START_DATE, J.END_DATE, J.JOB_ID, J.DEPARTMENT_ID
FROM JOB_HISTORY J
FULL JOIN EMPLOYEES E
ON E.EMPLOYEE_ID = J.EMPLOYEE_ID
ORDER BY J.EMPLOYEE_ID;

-------서브쿼리------------------------------------------------------------------
--하나의 SELECT문으로 해결이 안될때 사용

------단일행 서브쿼리
--NANCY보다 급여를 많이 받는 사람은?
SELECT FIRST_NAME, SALARY FROM EMPLOYEES WHERE FIRST_NAME= 'Nancy';
--위의 쿼리를 실행해서 12008을 알아냄
SELECT FIRST_NAME, SALARY FROM EMPLOYEES WHERE SALARY > 12008;
--이렇게 하면 쿼리를 두번 실행해야 함.

SELECT FIRST_NAME, SALARY FROM EMPLOYEES WHERE SALARY > (SELECT SALARY FROM EMPLOYEES WHERE FIRST_NAME = 'Nancy');
--서브쿼리는 ()안에 넣어주면 됨. 괄호 안에서 서브 쿼리 끝나고 세미콜론 찍어줄 필욘 없음!!

--전체평균보다 많이 받는 사람은?
SELECT FIRST_NAME, SALARY FROM EMPLOYEES WHERE SALARY > (SELECT AVG(SALARY) FROM EMPLOYEES);
--Q.근데 NULL이 포함되어 있을수도 있으니까 더 정확히 하려면 서브쿼리 어떻게 한다고...???

------다중행 서브쿼리
--Q.다중행 연산자: IN, ANY, ALL 등은 서브쿼리에 여러번 와도 됨
--에러났을 때 에러코드만 구글에 치면 해결방법 다 나옴.

--david보다 월급 많이 받는사람
SELECT FIRST_NAME, SALARY FROM EMPLOYEES WHERE FIRST_NAME = 'David';
--위를 실행해보면 알겠지만 데이비드 여러명임. 그래서 아래서  ANY써줌. Q.근데 그게 무슨뜻...?
SELECT FIRST_NAME, SALARY FROM EMPLOYEES WHERE SALARY > ANY(SELECT SALARY FROM EMPLOYEES WHERE FIRST_NAME = 'David');

--각각의 데이비드 들의 같은 부서 사람들
SELECT FIRST_NAME, DEPARTMENT_ID, JOB_ID
FROM EMPLOYEES
WHERE DEPARTMENT_ID IN (SELECT DEPARTMENT_ID FROM EMPLOYEES WHERE FIRST_NAME= 'David');
--상호연관 서브쿼리는 오래 돌기 때문에 기능, 속도 저하됨. 조회와 같은 기능적인 서브쿼리 사용할때 쓰면 안됨.

--스칼라 서브쿼리도 데이터 양이 많아질수록 점점 느려짐.
SELECT FIRST_NAME, (SELECT DEPARTMENT_NAME FROM DEPARTMENTS D WHERE D.DEPARTMENT_ID = E.DEPARTMENT_ID) AS DEPARTMENT_NAME
FROM EMPLOYEES E
ORDER BY FIRST_NAME;
--이렇게 서브쿼리를 짜면 DEPARTMENT_ID 하나하나 한줄씩 돌게 됨 그래서 오래 걸림. 데이터가 많으면 그냥 JOIN으로 하기
--Q.WHERE절에 함수 쓰면 안좋아..?

SELECT FIRST_NAME, DEPARTMENT_NAME
FROM EMPLOYEES E
JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
ORDER BY FIRST_NAME;

-------인라인 뷰------
--FROM 절에 서브쿼리 온것. 
SELECT ROW_NUMBER, FIRST_NAME, SALARY
FROM (SELECT FIRST_NAME, SALARY, ROW_NUMBER() OVER (ORDER BY SALARY DESC) AS ROW_NUMBER
     FROM EMPLOYEES
     ORDER BY SALARY DESC) --가상의 테이블을 만들어 줌.
WHERE ROW_NUMBER BETWEEN 1 AND 10;